/**
 * 486. 预测赢家
 * https://leetcode-cn.com/problems/predict-the-winner/
 * 给定一个表示分数的非负整数数组。 玩家1从数组任意一端拿取一个分数，随后玩家2继续从剩余数组任意一端拿取分数，
 * 然后玩家1拿，……。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。
 * 给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。

    示例 1:
    输入: [1, 5, 2]
    输出: False
    解释: 一开始，玩家1可以从1和2中进行选择。
    如果他选择2（或者1），那么玩家2可以从1（或者2）和5中进行选择。如果玩家2选择了5，那么玩家1则只剩下1（或者2）可选。
    所以，玩家1的最终分数为 1 + 2 = 3，而玩家2为 5。
    因此，玩家1永远不会成为赢家，返回 False。

    示例 2:
    输入: [1, 5, 233, 7]
    输出: True
    解释: 玩家1一开始选择1。然后玩家2必须从5和7中进行选择。无论玩家2选择了哪个，玩家1都可以选择233。
    最终，玩家1（234分）比玩家2（12分）获得更多的分数，所以返回 True，表示玩家1可以成为赢家。

    注意:
    1 <= 给定的数组长度 <= 20.
    数组里所有分数都为非负数且不会大于10000000。
    如果最终两个玩家的分数相等，那么玩家1仍为赢家。
*/

// 区间 dp 问题，但是难点在于： dp 不能保存当前选手能拿到的最大值，要判断当前选手能不能赢，是跟另一个选手的“最大值”交错的，
// 当前选手的最大值，即 dp[i][j] 要：后手的的最大值里？？
// 用 dp[i][j] 表示：当前选手比后手 多拿 的最大量值
// 所以 dp[i][j]：如果选了左边 num[i]，则当前的 dp 为 -dp[i+1][j] + num[i]，-dp[i+1][j] 是后手拿到的 比你多 的值，你要用当前的 num 减去人家比你多的
//               如果选了左边 num[j]，则当前的 dp 为 -dp[i][j-1] + num[j]，-dp[i][j-1] 是后手拿到的 比你多 的值，你要用当前的 num 减去人家比你多的
// 所以 dp[i][j] = max(-dp[i+1][j] + num[i]，-dp[i][j-1] + num[j])
// 最后看，dp整个跨度的值，大于 0 还是小于 0 ，即可，即，你比对手多吗
// 从动态转移方程或者自己画表的过程可以看出：当前 dp 的值依赖左边和下边的值，所以 i 逆序
export const PredictTheWinner = (nums) => {
    let n = nums.length;
    let dp = Array(n).fill(null).map(_ => Array(n).fill(0));

    // 对角线初始化
    for (let i = 0; i < n; i++) dp[i][i] = nums[i];

    for (let i = n-1; i >=0; i--) {
        for (let j = i+1; j < n; j++) {
            dp[i][j] = Math.max(-dp[i+1][j] + nums[i], -dp[i][j-1] + nums[j]);
        }
    }

    return dp[0][n-1] >= 0;
}
