/**
 * 375. 猜数字大小 II
 * https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/
 * 
 * 我们正在玩一个猜数游戏，游戏规则如下：

    我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。
    每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。
    然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。

    示例:

    n = 10, 我选择了8.

    第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。
    第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。
    第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。

    游戏结束。8 就是我选的数字。

    你最终要支付 5 + 7 + 9 = 21 块钱。
    给定 n ≥ 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏。
*/

// 题意是：最差情况下的最优解，
// 如果 n = 5，只给 6块钱，根本无法保证完成任务。比如正确答案是5，你用二分策略，最终要花7块。
// 如果先猜 4，那不管答案是什么，6 块钱都够了
// 找到一个稳赢的遍历方法，同时计算它的代价
// 问题不是二分不行，而是先猜谁不一定
// 使用动态规划的好处在于我可以穷举所有的情况，对于这个题来说，就是指动态规划的方法可以把每一个数字都当作分割点，而二分只能把中间的数字当作分割点。

// 所以对每一个区间 [i, j]，要遍历每个数当一次先猜数，计算每个先猜数下的代价，取最小的。而对于特定的先猜数，他的代价要取这次遍历中最大的

// 比如 n=5，需要循环 1-5 分别为先猜数。比如先猜 1，那先猜 1 的代价是 1 + 区间 [2,5] 的最大值；
// 如果先猜 2，代价是:
//      如果答案为 1，代价是 2 + dp[1,1]
//      如果答案为 2，代价是 0
//      如果答案为 [3,5]，代价是 2 + dp[3,5]，dp[3,5]是保证到这个区间稳赢的最小值了，和我们要的是猜 2 的最大值是两回事
//  ，3，4，5同理
// 区间 [2,5] 的最小花费同上，要遍历 2-5，，比如先猜 2，那再看区间 [3,5]，依次类推。
// 可以看出来 [2,5] 是依赖 [3.5] 的，所以竖向上，二维表格要倒着填。

// 我们要的是先猜 1 2 3 4 5 代价中最小的，确定先猜数 2 后，我们要 2 为分割点的所有情况的最大值(以保证能赢)，计算先猜 2 时答案分别为 1 2 3 4 5 的代价，这个代价取小的

// 保证能赢的最小值，就先得遍历出所有包赢的情况，在其中取最小值

// 很赞：https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/solution/dong-tai-gui-hua-c-you-tu-jie-by-zhang-xiao-tong-2/
export const getMoneyAmount = (n) => {
    if (n < 2) return 0;

    let dp = Array(n+1).fill(null).map(_ => Array(n+1).fill(Number.MAX_SAFE_INTEGER));

    // 对角线，即区间[3,3]等，就一个数，代价是 0，不用猜就它一个
    for (let i = 0; i <= n; i++) {
        dp[i][i] = 0;
    }

    // 这是 n 的遍历，每个 n 是我们要处理的一个完整流程，为了得到最后的 n
    // 因为多声明了边界0，对角线又已经初始化了，所以从 2 开始，画表可以看出来
    for (let j = 2; j <= n; j++) {
        // n 确定之后，要遍历从 1 到 n，看先猜哪个代价小
        for (let i = j-1; i >= 1; i--) {
            // 边界需要特殊处理，不然越界
            // 指定的 n 的代价计算
            // for (let k = i; k <= j; k++) {
            for (let k = i+1; k <= j-1; k++) {
                // 这里是在遍历讨论谁是答案，cur 是指定的答案的代价，要最大的
                let cur = Math.max(dp[i][k-1], dp[k+1][j]) + k;
                // 这里是不同 k，即先猜不同数字之间的比较，选最小的代价，
                dp[i][j] = Math.min(cur, dp[i][j]);
            }
            // 处理边界，即先猜 i 或者 j 的情况的取值
            dp[i][j] = Math.min(i+dp[i+1][j], dp[i][j]);
            dp[i][j] = Math.min(j+dp[i][j-1], dp[i][j]);
        }
    }

    return dp[1][n];
}