/**
 * 1155. 掷骰子的N种方法
 * 这里有 d 个一样的骰子，每个骰子上都有 f 个面，分别标号为 1, 2, ..., f。
    我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。
    如果需要掷出的总点数为 target，请你计算出有多少种不同的组合情况（所有的组合情况总共有 f^d 种），
    模 10^9 + 7 后返回。

    示例 1：
    输入：d = 1, f = 6, target = 3
    输出：1
    
    示例 2：
    输入：d = 2, f = 6, target = 7
    输出：6
   
    示例 3：
    输入：d = 2, f = 5, target = 10
    输出：1
    
    示例 4：
    输入：d = 1, f = 2, target = 3
    输出：0
    
    示例 5：
    输入：d = 30, f = 30, target = 500
    输出：222616187
     
    提示：
    1 <= d, f <= 30
    1 <= target <= 1000

    链接：https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum
*/
// TODO: 三刷！分组背包还是有点厉害的，得多练几个才好，虽然套路一样，但是判别有点思考
/**
 * 这个套模板的味道还是挺重的 - 组合背包，是指定 target 又可选了，但多了个分组，就先遍历分组，
 * 1. 可选择
 * 2. 组成目标 target
 * 3. 分成 k 组，每组物品是互斥的
 * 
 * 
 * 类型判定：
 * 但是，这不是简单的 01 背包(不可重用背包)或者组合/完全背包(可重用背包)，而是个组合背包，是前两者的组合
 * 
 * 组合背包公式：
 * 最外层为分组 k, 然后遍历 target，最后遍历 nums【固定的！！！不用分析是否与顺序有关】
 * 
 * 这里三层循环的顺序目的是：保证了每一组内的物品最多只有一个会被添加到背包中 -- from 背包九讲
*/
/**
 * 分组背包原型：背包九讲 - 第六章
 * 
 * 有 N 件物品和一个容量为 V 的背包。第 i 件物品的费用是 Ci，价值是 Wi。
 * 这些 物品被划分为 K 组，每组中的物品互相冲突，最多选一件。
 * 求解将哪些物品装入背包 可使这些物品的费用总和不超过背包容量，且价值总和最大。
 * 
 * 转移方程：dp[i][j]+=dp[i-1][j-f]
 * 
 * 三层循环不可换顺序，必须。最后一层是 nums
 * 
 * 是的，这样是不能调换的。 因为比方说k1物体更新了f[10], 然后接下来k2物体在f[10]的基础上更新了f[20]。 那么一个组的物体就用了2个(物体k1, k2)。 -- 摘自https://www.acwing.com/community/content/302/
*/
var numRollsToTarget = function(d, f, target) {
    // let dp = Array(d).fill(null).map(_ => Array(target).fill(0));
    let dp = Array(d+1).fill(null).map(_ => Array(target+1).fill(0));
    // dp 是用 i 个筛子投出 目标 j 的种数
    dp[0][0] = 1;

    // 背包九讲 - 中间那层 target 的遍历要从右向左
    for (let i = 1; i <= d; i++) {
        for (let j = target; j >= 1; j--) {
            // k 是 nums，是从 1 开始的，是由题目来的
            // && j >= k 是过滤背包小于物品大小的无效更新，其实也是防止数组越界
            for (let k = 1; k <= f && j >= k; k++) {
                // dp[i][j] += dp[i-1][j-k];
                // 这个肯定不对啊，哪能不取模的和取模的运算，肯定是对最后的结果取模再保存啊
                // dp[i][j] += (dp[i-1][j-k]) % Math.pow(10, 9) + 7;
                // 大数取模
                dp[i][j] += dp[i-1][j-k];
                dp[i][j] %= Math.pow(10, 9) + 7;
            }
        }
    }
    // 这题中，中间那层 target 的遍历要从左向右也可以
    for (let i = 1; i <= d; i++) {
        for (let j = 1; j <= target; j++) {
            // k 是 nums，是从 1 开始的，是由题目来的
            // && j >= k 是过滤背包小于物品大小的无效更新，其实也是防止数组越界
            for (let k = 1; k <= f && j >= k; k++) {
                // dp[i][j] += dp[i-1][j-k];
                // 这个肯定不对啊，哪能不取模的和取模的运算，肯定是对最后的结果取模再保存啊
                // dp[i][j] += (dp[i-1][j-k]) % Math.pow(10, 9) + 7;
                // 大数取模
                dp[i][j] += dp[i-1][j-k];
                dp[i][j] %= Math.pow(10, 9) + 7;
            }
        }
    }
    return dp[d][target];
};
