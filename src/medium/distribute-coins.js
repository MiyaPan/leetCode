/**
 * 979. 在二叉树中分配硬币
 * 给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。
    在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。
    返回使每个结点上只有一枚硬币所需的移动次数。

    示例 1：

    输入：[3,0,0]
    输出：2
    解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。
    示例 2：

    输入：[0,3,0]
    输出：3
    解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。
    示例 3：

    输入：[1,0,2]
    输出：2
    示例 4：

    输入：[1,0,0,null,3]
    输出：4

    提示：
    1<= N <= 100
    0 <= node.val <= N
    链接：https://leetcode-cn.com/problems/distribute-coins-in-binary-tree
*/
// TODO: 三刷！
/**
 * =============================  
 * 二刷
*/
var distributeCoins = function(root) {
    let ans = 0;
    const dfs = () => {
        if (!root) return 0;
        let l = distributeCoins(root.left);
        let r = distributeCoins(root.right);

        // ans 是左右要移动的量，而不管当前节点能不能消化，能不能消化是当前节点向父节点汇报的值，用以计算的
        // 在最小子树里进行消化是最小的代价
        ans += Math.abs(l) + Math.abs(r);

        return l + (root.val -1) + r;
    }
    dfs(root);
    return ans;
};

















/**
 * =============================  
 * 一刷
*/
// 思路：题目就是很好的提示，题目需要构造出每个节点都为 1 的树吗，不用，题目只要统计次数
// 所以不需要真的挪，所以子往父和父往子挪是一样的，可以一样对待，反正都是加 1 次
// 肯定不是从树根开始判，而要自底向上，那方法就固定了，就是递归的 DFS
// 怎么个递归法呢：从最小单位开始，以最左的 3 个节点为例，
// 看例子可以看出，对于这个 3 个节点的子树：移动次数 = |左子树需要或者差的值| + |右子树需要或者差的值|
// 这 3 个节点的 root 还得往上返值，方便上层递归计算，返多少呢
// 返 它需要的值或者差值，他需要多少或者差多少呢，= 左右子树需要拿出或者拿入的值 + (root.val - 1)， 它自己留下 1，剩下的拿走或者差
// 可见，需要或者差多少，对于题目来说是一样的，所以只需要关注绝对值即可

// 最终结果就等于每个节点的 过载量(移动次数) 的 加和，而不是最终 return 的根节点的值哦
export const distributeCoins = (root) => {
    let ans = 0;

    function dfs(root) {
        if (!root) return 0;
    
        // 这里不能取绝对值，因为存在 父节点-1，子节点也 -1，
        // 比如[4,0,null,null,0,null,0]这个时候，父节点网上返回，得给 2 也就是 -2的绝对值，而不能是 |—1| + 0 + (0-1) = 0
        // 告诉上一级的永远是正负加和的，而不是绝对值加和，这样上层才知道你们之前可以协调多少，还需要补多少，
        // 和ans区别开，ans是记录每个节点的差值或者拿出的绝对值，这个没问题，因为内部协调，也要移动
        let l = dfs(root.left);
        let r = dfs(root.right);
    
        ans += Math.abs(l) + Math.abs(r);
    
        return (root.val - 1) + l + r;
    }

    dfs(root);

    return ans;
}
