# react 注意点

## 小点

### state
1. 构造函数是唯一可以给 state 赋值的地方；setState 的更新的异步的，批量的

2. setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：

```js
this.setState((state, props) => ({
  counter: state.counter + props.increment
}));
```
### 列表的 key

渲染简单的无状态组件 不带 key 更快，因为可以判定为同个节点然后递归进去发现只有文本不同，只修改文本。
但是复杂状态的就不能这样“复用”了，比如：
为什么还要建议带key呢？因为这种模式只适用于渲染简单的无状态组件。对于大多数场景来说，列表组件都有自己的状态。

举个例子：一个新闻列表，可点击列表项来将其标记为"已访问"，可通过tab切换“娱乐新闻”或是“社会新闻”。

不带key属性的情况下，在“娱乐新闻”下选中第二项然后切换到“社会新闻”，"社会新闻"里的第二项也会是被选中的状态，因为这里复用了组件，保留了之前的状态。要解决这个问题，可以为列表项带上新闻id作为唯一key，那么每次渲染列表时都会完全替换所有组件，使其拥有正确状态。

这只是个简单的例子，实际应用会更复杂。带上唯一key虽然会增加开销，但是对于用户来说基本感受不到差距，而且能保证组件状态正确，这应该就是为什么推荐使用唯一id作为key的原因。至于具体怎么使用，就要根据实际情况来选择了。

)key的作用是为了在数据变化时强制更新组件，以避免“原地复用”带来的副作用，官方文档也说明了不带key性能更好https://cn.vuejs.org/v2/guide/list.html#%E7%BB%B4%E6%8A%A4%E7%8A%B6%E6%80%81


vue和react虽然都采用了diff算法。 但是react本身的设计和vue的设计是截然不同的， vue采用了更加细粒度的更新组件的方式，即给每一个属性绑定监听， 而react是采用自顶而下的更新策略，每次小的改动都会生成一个全新的vdom。从而进行diff，如果不写key，可能就会发生本来应该更新却没有更新的bug。
这个bug其实和diff算法有关，react团队完全可以写一个没有这个“bug”版本的代码， 但是这是一种权衡，一种性能和方便使用的权衡。 写不写key能够提高性能的根本在于一方面diff算法会优先判断key是否相同，如果相同则不进行后面的运算。 如果key相同，就更好了，根本不需要重新创建节点

总结， 更确切的说应该是diff算法在你的复杂的列表稳定的时候能够明显提高性能，因为节点可以重用。
但是对于列表频繁更新的场景， 节点不能重用，但是diff 可以省略一部分逻辑，因此性能也会更好。
但是两者的性能优化不在同一个纬度，一个是 创建和更新节点（我称之为渲染器）的优化，
一个是DOM diff 算法（我称之为核心引擎）的优化
https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/1



key 会传递信息给 React ，但不会传递给你的组件。如果你的组件中需要使用 key 属性的值，请用其他属性名显式传递这个值