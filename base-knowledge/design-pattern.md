# 设计模式

## 设计原则

### SOLID 原则

单一职责原则(Single Responsibility Principle): 一个类或者模块只负责完成一个职责
开闭原则(Open Closed Principle): 对扩展开放、对修改关闭。添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）
里氏替换原则(Liskov Substitution Principle): 只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常。子类可以改变函数的内部实现逻辑，但不能改变原有的行为约定。包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。
接口隔离原则(Interface Segregation Principle): 调用者不应该依赖它不需要的接口。
    i. 如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。
    ii. 如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。
    iii. 如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。

    ps: 单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。
依赖反转原则(Dependence Inversion Principle): 
    1. 控制反转：指的是代码执行流程的控制，反转指的是没用框架之前代码流程由开发者控制，使用框架后执行流程由框架控制。流程的控制权从程序员“反转”给了框架。
    2. 依赖注入：不通过 new 在类内创建对象，而是将需要的对象在外部创建好，通过构造函数、函数传参的形式注入进来。
    依赖反转原则和控制反转类似：高层模块不依赖低层模块，而是依赖抽象(接口或抽象类)，底层实现抽象(接口或抽象类)

### KISS 原则
Keep It Simple and Stupid：尽量保持简单。

### YAGNI 原则
You aren't gonna need it：你不需要它，就是不要过度设计

### DRY 原则
Don't Repeat Yourself: 不要写重复的代码。

### 迪米特法则
高内聚，低耦合

## 常用模式

### 创建型
1. 单例模式
全局控制访问，数据库链接、store 等都是

2. 简单工厂和工厂方法
简单工厂：if else 的去创建不同的产品对象，提供给别人用
工厂方法：每个产品都去创建自己的工程，别人用的时候直接从各种的工厂获取

3. 建造者模式
对于构造函数需要传巨多参数的情况，通过 setXX().setXX() 一层层去设置，构造函数参数只需要必传项。进一步的，简单的对对象的 setXX 无法实现联动的校验或者依赖(比如先set了年龄18，又set了老年人就不对了)，所以可以再抽离一层专门的建造者，和原始类实现相同的接口，在其中做好校验，然后统一的去 new 原始class(this-建造者自己)，让原始类按照自己去初始化。

### 结构型

4. 代理模式

概念：为其他对象提供一种代理以控制对这个对象的访问。给原始对象的使用加一层“中间层”，以扩展它。

主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

何时使用：想在访问一个类时做一些控制。

如何解决：增加中间层。

关键代码：实现与被代理类组合。
————————————————
原文链接：https://blog.csdn.net/jiadajing267/article/details/106750920

代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中。- 《设计模式之美》

5. 装饰器模式

概念：动态的 给对象添加功能，而不改变原来的结构，比用继承写很多的静态类更加灵活。通常装饰器，可以运行时扩充类的功能，

原理：增加一个装饰类包裹原来的类，包裹的方式一般是降原来类的对象最为装饰类的构造函数的参数。在不需要装饰类的地方还可以使用原来的类。装饰类必须和原来的类实现相同的接口。
    装饰器是类继承外的另一种选择。**类继承在编译时增加行为，而装饰器在运行时增加行为**。

主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。

何时使用：在不想增加很多子类的情况下扩展类。

如何解决：将具体功能职责划分，同时继承装饰者模式。

优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

缺点：多层装饰比较复杂。

使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。

注意事项：可代替继承。
————————————————
原文链接：https://blog.csdn.net/jiadajing267/article/details/106750920

#### 代理模式和装饰器模式的关系

相同点：都是结构型模式；都增强原来类的功能；都使用了组合关系。

不同点 - 侧重点不同：
    装饰器模式重点是**对对象功能的扩展**，它不关心外部如何调用，只注重对对象功能的增强，装饰后还是对象本身；
    代理模式重点是**对流程的控制和辅助**，它可以控制对象做某些事，重点是借用对象的功能实现了某一流程，而不关心对象功能如何。

    装饰器模式应当为所装饰的对象提供增强功能，而代理模式对所代理对象的使用施加控制，并不提供对象本身的增强功能。-From：《java与模式》阎宏编著

6. 适配器模式

就是做适配的，将不兼容的接口转换为可兼容的接口，使得不兼容的类可以一起工作。具体到代码里有两种常用的实现方式：
1. 通过继承原来的类实现
2. 通过组合关系实现，有点像 代理模式
选择：当要扩展的接口和原始类的接口差不多用继承，差很多就组合好了

7. 桥接模式
...太南了，不学了...

#### 结构型常用的 4 种模式 - 代理、桥接、装饰器、适配器 的区别

他们都是结构型设计，代码结构类似，都可以成为 `Wrapper` 模式，也就都是**通过 `Wrapper类` 二次封装原始类**。

区别：尽管代码结构类似，但是他们的用意不同，要解决的问题不同，场景不同。

- 代理模式：在不改变原始类接口的条件下，为原始类定义一个代理类，**主要目的是控制访问，而不是增强功能，这是它跟装饰器最大的不同**。
- 桥接模式：目的是将接口和实现分离，从而使它们较为容易，也相互独立的修改。
- 装饰器模式：在不改变原始类接口的条件下，对原始类进行功能增强，可以叠加使用。
- 适配器模式：一种事后的补救策略，**适配器提供跟原始类不同的接口，而代理/桥接/装饰器 都是提供跟原始类相同的接口。

### 行为型

8. 观察者模式，又叫发布订阅模式

一个对象之间的一对多的依赖，一个对象改变，其他都能收到通知。简单代码见base-js